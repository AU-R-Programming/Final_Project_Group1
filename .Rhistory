# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
solve(t(X)%*%X) %*% t(X)%*%y
}
# loss function function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"  # optimization method
)
}
# putting above functions together
opt_beta_est <- function(X, y){
design <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = design, y = y)
beta_opt <- estimate_beta(X = design, y = y, beta_init = beta_initial)
cat("Estimated beta:", result$par, "\n")
optimal_beta_est <- return(beta_opt$par)
}
X <- matrix(rnorm(n * p), nrow = n, ncol = p)  # Predictor matrix
n <- 100
p <- 3
X <- matrix(rnorm(n * p), nrow = n, ncol = p)  # Predictor matrix
true_beta <- c(0.5, -1, 0.75, 1.2)            # True beta (with intercept)
y <- rbinom(n, 1, plogis(cbind(1, X) %*% true_beta))
opt_beta_est(X = X, y = y)
# putting above functions together
opt_beta_est <- function(X, y){
design <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = design, y = y)
beta_opt <- estimate_beta(X = design, y = y, beta_init = beta_initial)
cat("Estimated beta:", beta_opt$par, "\n")
optimal_beta_est <- return(beta_opt$par)
}
opt_beta_est(X = X, y = y)
# testing code
set.seed(42)  # For reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(0.5, -1, 0.75)  # True coefficients
beta_true <- c(1.5, 0.5, -1, 0.75)  # True coefficients
data <- simulate_data(n, p, beta_true)
X <- data$X
# simulating data for function
simulate_data <- function(n, p, true_beta) {
set.seed(123)  # For reproducibility
# Generate random predictor matrix X (standard normal distribution)
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
# Calculate p_i
p_i <- 1 / (1 + exp(-X %*% true_beta)) # probability for y generation
# Generate binary response variable y
y <- rbinom(n, size = 1, prob = p_i)
list(X = X, y = y)
}
# testing code
set.seed(42)  # For reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(1.5, 0.5, -1, 0.75)  # True coefficients
data <- simulate_data(n, p, beta_true)
beta_true <- c(0.5, -1, 0.75)  # True coefficients
data <- simulate_data(n, p, beta_true)
X <- data$X
y <- data$y
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
n <- 100
p <- 3
X <- matrix(rnorm(n * p), nrow = n, ncol = p)  # Predictor matrix
true_beta <- c(0.5, -1, 0.75, 1.2)            # True beta (with intercept)
y <- rbinom(n, 1, plogis(cbind(1, X) %*% true_beta))
opt_beta_est(X = X, y = y)
# testing code
set.seed(42)  # For reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(0.5, -1, 0.75)  # True coefficients
data <- simulate_data(n, p, beta_true)
X <- data$X
y <- data$y
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
View(opt_beta_est)
# testing code
set.seed(42)  # For reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(0.5, -1, 0.75)  # True coefficients
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
p_i <- 1 / (1 + exp(-X %*% true_beta)) # probability for y generation
p_i <- 1 / (1 + exp(-X %*% true_beta)) # probability for y generation
# simulating data for function
simulate_data <- function(n, p, true_beta) {
set.seed(123)  # for reproducibility
# generate random predictor matrix X (standard normal distribution)
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
# Calculate p_i
p_i <- 1 / (1 + exp(-X %*% true_beta)) # probability for y generation
# Generate binary response variable y
y <- rbinom(n, size = 1, prob = p_i)
list(X = X, y = y)
}
data <- simulate_data(n, p, beta_true)
X <- data$X
X <- data$X
y <- data$y
# testing final function
opt_beta_est(X = X, y = y)
# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
solve(t(X)%*%X) %*% t(X)%*%y
}
# loss function function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"  # optimization method
)
}
# putting above functions together
opt_beta_est <- function(X, y){
beta_initial <- initial_beta(X = X, y = y)
beta_opt <- estimate_beta(X = X, y = y, beta_init = beta_initial)
cat("Estimated beta:", result$par, "\n")
}
# simulating data for function
simulate_data <- function(n, p, true_beta) {
set.seed(123)  # For reproducibility
# Generate random predictor matrix X (standard normal distribution)
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
# Calculate p_i
p_i <- 1 / (1 + exp(-X %*% true_beta)) # probability for y generation
# Generate binary response variable y
y <- rbinom(n, size = 1, prob = p_i)
list(X = X, y = y)
}
# testing code
set.seed(42)  # For reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(0.5, -1, 0.75)  # True coefficients
data <- simulate_data(n, p, beta_true)
X <- data$X
y <- data$y
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
set.seed(42)  # For reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(0.5, -1, 0.75)  # True coefficients
data <- simulate_data(n, p, beta_true)
X <- data$X
y <- data$y
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
p_i <- 1 / (1 + exp(-X %*% true_beta)) # probability for y generation
p_i <- 1 / (1 + exp(-X %*% beta_true)) # probability for y generation
y <- rbinom(n, size = 1, prob = p_i)
# testing final function
opt_beta_est(X = X, y = y)
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
solve(t(X)%*%X) %*% t(X)%*%y
}
# loss function function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"  # optimization method
)
}
# putting above functions together
opt_beta_est <- function(X, y){
design <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = design, y = y)
beta_opt <- estimate_beta(X = design, y = y, beta_init = beta_initial)
cat("Estimated beta:", result$par, "\n")
optimal_beta_est <- result$par
return(optimal_beta_est)
}
# testing code
set.seed(42)  # for reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(0.5, -1, 0.75)  # True coefficients
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
p_i <- 1 / (1 + exp(-X %*% beta_true)) # probability for y generation
y <- rbinom(n, size = 1, prob = p_i)
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
# testing final function
opt_beta_est(X = x, y = y)
# testing final function
opt_beta_est(X = X, y = y)
# putting above functions together
opt_beta_est <- function(X, y){
design <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = design, y = y)
beta_opt <- estimate_beta(X = design, y = y, beta_init = beta_initial)
cat("Estimated beta:", result$par, "\n")
optimal_beta_est <- result$par
return(optimal_beta_est)
}
# testing final function
opt_beta_est(X = X, y = y)
# testing code
set.seed(42)  # for reproducibility
n <- 100   # Number of observations
p <- 4     # Number of predictors
beta_true <- c(1.25, 0.5, -1, 0.75)  # True coefficients
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
p_i <- 1 / (1 + exp(-X %*% beta_true)) # probability for y generation
y <- rbinom(n, size = 1, prob = p_i)
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
# testing code
set.seed(42)  # for reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(1.25, 0.5, -1, 0.75)  # true coefficients, first term is intercept
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
p_i <- 1 / (1 + exp(-X %*% beta_true)) # probability for y generation
design <- cbind(rep(1, n), X)
p_i <- 1 / (1 + exp(-design %*% beta_true)) # probability for y generation
y <- rbinom(n, size = 1, prob = p_i)
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
# testing final function
opt_beta_est(X = X, y = y)
# putting above functions together
opt_beta_est <- function(X, y){
X <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = X, y = y)
beta_opt <- estimate_beta(X = X, y = y, beta_init = beta_initial)
cat("Estimated beta:", result$par, "\n")
optimal_beta_est <- result$par
return(optimal_beta_est)
}
# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
X <- cbind(rep(1, n), X)
solve(t(X)%*%X) %*% t(X)%*%y
}
# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
solve(t(X)%*%X) %*% t(X)%*%y
}
# loss function function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"  # optimization method
)
}
# putting above functions together
opt_beta_est <- function(X, y){
X <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = X, y = y)
beta_opt <- estimate_beta(X = X, y = y, beta_init = beta_initial)
cat("Estimated beta:", result$par, "\n")
optimal_beta_est <- result$par
return(optimal_beta_est)
}
# testing code
set.seed(42)  # for reproducibility
n <- 100   # Number of observations
p <- 3     # Number of predictors
beta_true <- c(1.25, 0.5, -1, 0.75)  # true coefficients, first term is intercept
X <- matrix(rnorm(n * p), nrow = n, ncol = p)
design <- cbind(rep(1, n), X)
p_i <- 1 / (1 + exp(-design %*% beta_true)) # probability for y generation
y <- rbinom(n, size = 1, prob = p_i)
# testing final function
opt_beta_est(X = X, y = y)
# test other code
initial_beta <- function(X, y) {
solve(t(X) %*% X) %*% t(X) %*% y
}
# Loss function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# Beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"
)
}
# Function to combine all steps and estimate beta
opt_beta_est <- function(X, y) {
# Add intercept column
X <- cbind(1, X)
# Initial beta using least squares
beta_initial <- initial_beta(X = X, y = y)
# Optimize beta using loss function
beta_opt <- estimate_beta(X = X, y = y, beta_init = beta_initial)
# Print results
cat("Estimated beta:", beta_opt$par, "\n")
return(beta_opt$par)
}
# Test code
set.seed(42)  # for reproducibility
n <- 100      # Number of observations
p <- 3        # Number of predictors
# True beta coefficients, including intercept
beta_true <- c(1.25, 0.5, -1, 0.75)
# Generate data
X <- matrix(rnorm(n * p), nrow = n, ncol = p)   # Predictor matrix
design <- cbind(1, X)                           # Add intercept column
p_i <- 1 / (1 + exp(-design %*% beta_true))     # Probabilities
y <- rbinom(n, size = 1, prob = p_i)            # Response variable
# Estimate beta using function
estimated_beta <- opt_beta_est(X = X, y = y)
# Compare with true beta
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", estimated_beta, "\n")
opt_beta_est(X = X, y = y)
# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
solve(t(X)%*%X) %*% t(X)%*%y
}
# loss function function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"  # optimization method
)
}
# Function to combine all steps and estimate beta
opt_beta_est <- function(X, y) {
# Add intercept column
X <- cbind(rep(1,n), X)
# Initial beta using least squares
beta_initial <- initial_beta(X = X, y = y)
# Optimize beta using loss function
beta_opt <- estimate_beta(X = X, y = y, beta_init = beta_initial)
# Print results
cat("Estimated beta:", beta_opt$par, "\n")
return(beta_opt$par)
}
set.seed(42)  # for reproducibility
n <- 100      # Number of observations
p <- 3        # Number of predictors
# True beta coefficients, including intercept
beta_true <- c(1.25, 0.5, -1, 0.75)
# Generate data
X <- matrix(rnorm(n * p), nrow = n, ncol = p)   # Predictor matrix
design <- cbind(1, X)                           # Add intercept column
p_i <- 1 / (1 + exp(-design %*% beta_true))     # Probabilities
y <- rbinom(n, size = 1, prob = p_i)            # Response variable
# Estimate beta using function
estimated_beta <- opt_beta_est(X = X, y = y)
# Compare with true beta
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", estimated_beta, "\n")
opt_beta_est(X = X, y = y)
# Calculate initial beta values, least squares = (XtX)^-1 %*% XTy
initial_beta <- function(X, y) {
solve(t(X)%*%X) %*% t(X)%*%y
}
# loss function function
loss_func <- function(beta, X, y) {
p <- 1 / (1 + exp(-X %*% beta))
sum(-y * log(p) - (1 - y) * log(1 - p))
}
# beta optimization function
estimate_beta <- function(X, y, beta_init) {
optim(
par = beta_init,
fn = loss_func,
X = X,
y = y,
method = "BFGS"  # optimization method
)
}
# putting above functions together
opt_beta_est <- function(X, y){
X <- cbind(rep(1, n), X)
beta_initial <- initial_beta(X = X, y = y)
beta_opt <- estimate_beta(X = X, y = y, beta_init = beta_initial)
cat("Estimated beta:", beta_opt$par, "\n")
return(beta_opt$par)
}
# testing code
set.seed(42)  # for reproducibility
n <- 100   # number of observations
p <- 3     # number of predictors
beta_true <- c(1.25, 0.5, -1, 0.75)  # true coefficients
X <- matrix(rnorm(n * p), nrow = n, ncol = p)   # predictor matrix
design <- cbind(1, X)                           # add intercept column
p_i <- 1 / (1 + exp(-design %*% beta_true))     # probabilities
y <- rbinom(n, size = 1, prob = p_i)            # response variable
# testing final function
beta_opt <- opt_beta_est(X = X, y = y)
# calculate initial beta
beta_init <- initial_beta(X, y)
# estimate beta using optimization
result <- estimate_beta(X, y, beta_init)
# display results compared to true values
cat("True beta:", beta_true, "\n")
cat("Estimated beta:", result$par, "\n")
cat("Estimated beta:", beta_opt, "\n")
# display results compared to true values
cat("True beta:", beta_true, "\n")
